#!/usr/bin/env python
import sys
import polars as pl

MAPPING = {
    '0/0': '0',
    '0|0': '0',
    '1|0': '1',
    '0|1': '1',
    '1|1': '1',
    '1/1': '1',
    '0/1': '1'
}

def parse_args():
    import argparse
    # Argument definition
    parser = argparse.ArgumentParser()
    parser.add_argument("-i", "--input", metavar = 'input.tsv', type = str, help = 'Input dataframe from bcftools split-vep, with fields CHROM, POS, mutation_type, Consequence and genotypes',\
                            dest = 'input', required = True)
    parser.add_argument("-k", "--kmers", metavar = 'kmers.txt', type = str, help = 'Kmers list (with header)',\
                            dest = 'kmer', required = False, default = None)
    parser.add_argument("-o", "--out", metavar = 'prefix', type = str, help = 'Output file.',\
                            dest = 'out', required = False, default = "myanc.fa")
    parser.add_argument("--all", action='store_true', help = 'Add missing change-by-consequence combinations to the output dataframe.')
    return parser.parse_args()


def main():
    """Run entry point."""
    # Parse arguments
    args = parse_args()

    # Import data using the lazy API to save memory
    df = pl.scan_csv(args.input,
        has_header=True,
        separator='\t'
    ).select(
        pl.col("*").exclude("CHROM", "POS")
    ).group_by(
        'CHANGE'
    ).sum().collect()

    # If store all requested, add missing consequences
    if args.all:
        # Create minimal levels of factors to facilitate future merging.
        # first load all kmers
        kmers = pl.DataFrame(args.kmers, new_header=['CHANGE'])
        # Add them to the DF
        df = pl.concat((
                df[['CHANGE']],
                kmers
            ))

    # Add missing levels
    # First, we concatenate the full consequence-by-kmer with the output
    df = (
        df
            .select(pl.col(['CHANGE']).unique().implode())  # second, we find the unique values for the two level columns and implode them
            .explode('CHANGE')  # third, we explode the values once at the time, creating every combo of vals
            .join(df, how='left', on=['CHANGE']) # fourth, we add back the initial values
            .fill_null(0)  # finally, we set missing to zero
        )

    # Save data
    df.write_csv(args.out, separator='\t')

    sys.stderr.write( "All done\n" )


if __name__ == "__main__":
    main()