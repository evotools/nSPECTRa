#!/usr/bin/env python
import sys
from scipy.stats import gmean
from statistics import median
import pandas as pd

def get_base_counts(infile):
    values = {}
    for line in open(infile):
        kmer, cnt = line.strip().split()
        values[kmer] = float(cnt)
    return values

def correct_values(values, ktgts, kcounts, mode):
    total = sum(map(int, values))
    corrected = [ float(values[n]) / kcounts.get(k, 0) if mode == 1 else float(values[n]) / float(total) / kcounts.get(k, 0) for n, k in enumerate(ktgts) ]
    return corrected

deseq2norm = lambda x: x / (x / gmean(x)[0]).median()[0]

def main():
    kcounts = get_base_counts( sys.argv[2] )

    # Perform DeSeq2-like normalization first
    indf = pd.read_csv(sys.argv[1], delimiter=';')

    # Apply DeSeq2 normalization first
    indf[[c for c in indf.columns if ">" in c]] = deseq2norm(indf[[c for c in indf.columns if ">" in c]])
    indf.to_csv(sys.argv[1].replace('.csv', '.deseq2.csv'), index = False)

    # Run normalizatio by column
    for colname in [c for c in indf.columns if ">" in c]:
        k = colname.split('>')[0]
        indf[[colname]] = indf[[colname]] / kcounts.get(k, 0)
    indf.to_csv(sys.argv[1].replace('.csv', '.deseq2.NKnorm.csv'), index = False)

    for n, line in enumerate(open(sys.argv[1])):
        if n == 0:
            kstats = [ kmer.split('>')[0] for m, kmer in enumerate(line.strip().split(';')) if m > 0 ]
            print( line.strip() )
            continue
        line = line.strip().split(';')
        outline = map(str, [line[0]] + correct_values( line[1:], kstats, kcounts, int(sys.argv[3]) ))
        print(';'.join(outline))        

if __name__ == "__main__": 
    main()